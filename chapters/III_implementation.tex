\chapter{Implementacja}
\label{sec:rozdzial_III}

\section{Technologie i narzędzia}

Aplikacja została zaimplementowana w technologii ASP.NET Core MVC w środowisku
.NET 8. Do zarządzania bazą danych wykorzystano Microsoft SQL Server 2022.
Interfejs użytkownika został zbudowany przy użyciu TailwindCSS, zapewniającego
nowoczesny i responsywny wygląd, oraz Vue.js do obsługi interaktywnych
komponentów i wieloetapowych procedur. Całość projektu została objęta
konteneryzacją przy użyciu narzędzia Docker, co umożliwia łatwe wdrożenie i
utrzymanie aplikacji.

\subsection{Strona kliencka}
\label{sec:frontend_opis}

Część frontendowa aplikacji wykonana jest w dwóch metodykach. Pierwsza z nich
przeznaczona jest do tworzenia statycznych stron HTML, które są renderowane po
stronie serwera w sposób typowy dla wzorca MVC\@. Drugie podejście łączy
wstępną generację HTML z dynamicznym uzupełnianiem treści po stronie klienta
przy użyciu biblioteki Vue.js. Takie podejście zostało zastosowane w miejscach,
gdzie wymagana jest większa interaktywność, na przykład w formularzach
wieloetapowych czy dynamicznych listach.

\subsubsection{Razor}

Do tworzenia statycznych stron HTML wykorzystano silnik szablonów Razor, który
jest integralną częścią frameworka ASP.NET Core MVC\@. Razor umożliwia łączenie
kodu C\# z HTML w sposób czytelny i efektywny, co pozwala na dynamiczne
generowanie treści stron na serwerze przed ich wysłaniem do przeglądarki
klienta.

Z perspektywy klienta, strony wygenerowane za pomocą Razor są tradycyjnymi
stronami HTML, które mogą zawierać osadzone skrypty JavaScript i style CSS\@.
Dzięki temu możliwe jest tworzenie responsywnych i interaktywnych interfejsów
użytkownika, nawet jeśli główna logika renderowania stron odbywa się po stronie
serwera.

\subsubsection{Vue.js}
\label{sec:vue_opis}

Niektóre części aplikacji wymagają większej interaktywności i dynamicznego
zarządzania stanem interfejsu użytkownika (w celu zachowania wymogu
intuicyjności). Do ich implementacji wykorzystano bibliotekę Vue.js.

Strony te są początkowo generowane na serwerze przy użyciu Razor, a następnie
po załadowaniu w przeglądarce klienta, Vue.js przejmuje kontrolę nad
interaktywnymi elementami interfejsu użytkownika. Dzięki temu możliwe jest
dynamiczne aktualizowanie treści, obsługa zdarzeń użytkownika oraz zarządzanie
stanem aplikacji bez konieczności ponownego ładowania całej strony.

Aplikacje Vue.js są implementowane bezpośrednio w tagach \textit{script} w
niektórych plikach widoków. Ładowany jest wówczas globalny plik biblioteki,
który udostępnia wszelkie funkcjonalności jako właściwości globalnego obiektu
Vue. Następnie za jego pomocą tworzone są instancje aplikacji Vue, które są
przypisywane do określonych elementów DOM na stronie. Ten proces następuje w
przeglądarce użytkownika, co pozwala na płynne przejście od statycznego
renderowania do dynamicznej interaktywności.

W opisywanym projekcie aplikacje Vue.js używane są na dwa sposoby:

\begin{itemize}
      \item do zwiększania interaktywności prostych bądź zaawansowanych elementów
            interfejsu po stronie klienta bez potrzeby komunikacji z serwerem,
      \item do zarządzania bardziej złożonymi komponentami interfejsu, które wymagają
            komunikacji z serwerem w celu pobierania lub wysyłania danych.
\end{itemize}

W pierwszym przypadku często zachowywana jest logika renderowania po stronie
serwera, włącznie z tworzeniem formularzy za pomocą pomocników HTML ASP.NET
Core przy użyciu modeli widoków. Vue.js jest wtedy wykorzystywany do obsługi
interakcji użytkownika, takich jak walidacja danych wprowadzanych w
formularzach, dynamiczne dodawanie lub usuwanie elementów listy, czy
aktualizacja widoku na podstawie działań użytkownika bez konieczności ponownego
ładowania strony. Czasem jednak dane osadzane są bezpośrednio w zmiennej
JavaScript w widoku (po przekonwertowaniu do JSON), co pozwala na pełną
kontrolę nad renderowaniem interfejsu po stronie klienta przez samą aplikację
Vue.

W drugim przypadku Vue.js zarządza bardziej złożonymi komponentami, które
wymagają komunikacji z serwerem. Wówczas aplikacja przypomina bardziej wzorzec
SPA (Single Page Application), gdzie Vue.js odpowiada za renderowanie
interfejsu użytkownika, a komunikacja z serwerem odbywa się za pomocą
asynchronicznych żądań HTTP (przy użyciu Fetch API). Dane są pobierane z
serwera w formacie JSON, a następnie wykorzystywane do aktualizacji widoku w
czasie rzeczywistym. Podobnie, dane wprowadzone przez użytkownika są wysyłane z
powrotem na serwer w formacie JSON, gdzie są przetwarzane i zapisywane w bazie
danych. Nie jest to jednak pełna aplikacja SPA, ponieważ nawigacja między
różnymi stronami nadal odbywa się poprzez tradycyjne przeładowanie strony.

\subsubsection{JQuery i JavaScript}

Do obsługi prostych interakcji na stronach wykorzystano również bibliotekę
jQuery oraz czysty JavaScript. W miejscach, gdzie nie jest wymagana pełna
funkcjonalność Vue.js, jQuery pozwala na szybkie i efektywne manipulowanie
elementami DOM oraz obsługę zdarzeń. Dodatkowo odpowiada za walidację
formularzy po stronie klienta, co poprawia doświadczenie użytkownika poprzez
natychmiastowe informowanie o błędach przed wysłaniem danych na serwer.

JavaScript jest również używany do implementacji powszechnych funkcji dla
aplikacji, znajdujących się w plikach zewnętrznych, które są dołączane do
odpowiednich widoków.

\subsubsection{TailwindCSS}

Do stylizacji interfejsu użytkownika wykorzystano framework CSS o nazwie
TailwindCSS\@. Jest to narzędzie oparte na podejściu utility-first, które
umożliwia szybkie tworzenie responsywnych i estetycznych interfejsów
użytkownika poprzez stosowanie gotowych klas CSS bez konieczności pisania
własnych stylów od podstaw.

Głównymi zaletami TailwindCSS są jego elastyczność i możliwość tworzenia
responsywnych projektów. Framework oferuje szeroki zestaw klas, które pozwalają
na precyzyjne kontrolowanie wyglądu elementów interfejsu, takich jak marginesy,
wypełnienia, kolory, typografia i układ. Dzięki temu aplikacja została w prosty
sposób dostosowana do różnych rozmiarów ekranów, zapewniając optymalne
doświadczenie użytkownika na urządzeniach mobilnych, tabletach i komputerach
stacjonarnych.

Nad to użyto również wtyczki DaisyUI, która rozszerza możliwości TailwindCSS o
gotowe komponenty UI, takie jak przyciski, formularze, karty i nawigacje,
tworzone za pomocą określonych klas. Dzięki temu proces tworzenia interfejsu
użytkownika był szybszy i bardziej efektywny, pozwalając skupić się na
funkcjonalności aplikacji zamiast na szczegółach stylizacji.

\subsection{Strona serwerowa}

Część backendowa aplikacji została zaimplementowana przy użyciu frameworka
ASP.NET Core, opartego na platformie \.NET w wersji 8. Wykorzystano w nim różne
biblioteki i narzędzia dostępne w ekosystemie \.NET, aby zapewnić wydajność,
skalowalność i bezpieczeństwo aplikacji.

\subsubsection{ASP.NET Core}

Framework ASP.NET Core umożliwia tworzenie aplikacji webowych zgodnych z
wzorcem Model-View-Controller (MVC), co pozwala na oddzielenie logiki
biznesowej od warstwy prezentacji i danych. Nadal pozwala przy tym udostępniać
interfejs API w obrębie tej samej aplikacji, co zostało wykorzystane w
projekcie. ASP.NET Core oferuje wbudowane mechanizmy do obsługi routingu,
autoryzacji, uwierzytelniania oraz zarządzania sesjami, co ułatwia tworzenie
bezpiecznych i wydajnych aplikacji webowych. Dodatkowo, framework ten jest
wysoce konfigurowalny i wspiera nowoczesne praktyki programiste, takie jak
wstrzykiwanie zależności i middleware.

\paragraph{Entity Framework Core}

Do komunikacji z bazą danych wykorzystano Entity Framework Core (EF Core),
który jest popularnym narzędziem ORM (Object-Relational Mapping) dla platformy
\.NET\@. EF Core umożliwia programistom pracę z bazą danych za pomocą obiektów
C\#, eliminując potrzebę pisania bezpośrednich zapytań SQL\@. Dzięki temu
proces tworzenia, odczytu, aktualizacji i usuwania danych (CRUD) staje się
bardziej intuicyjny i zintegrowany z logiką aplikacji.

\paragraph{ASP.NET Core Identity}

Do zarządzania uwierzytelnianiem i autoryzacją użytkowników wykorzystano
bibliotekę ASP.NET Core Identity. Jest to kompleksowe rozwiązanie, które
umożliwia tworzenie i zarządzanie kontami użytkowników, obsługę ról oraz
implementację mechanizmów bezpieczeństwa, takich jak resetowanie haseł czy
weryfikacja dwuetapowa. ASP.NET Core Identity integruje się bezproblemowo z
frameworkiem ASP.NET Core, co pozwala na łatwe dodanie funkcji logowania i
zarządzania użytkownikami do aplikacji webowej oraz przechowywanie ich danych w
bazie danych za pośrednictwem Entity Framework Core.

\paragraph{WebOptimizer}

Do optymalizacji dostarczania statycznych plików JavaScript zastosowano
bibliotekę WebOptimizer. Narzędzie to umożliwia minifikację, łączenie i
kompresję plików statycznych, co prowadzi do zmniejszenia rozmiaru przesyłanych
zasobów i przyspieszenia ładowania stron internetowych. WebOptimizer
automatycznie przetwarza pliki podczas uruchamiania aplikacji, co ułatwia
zarządzanie zasobami i poprawia wydajność aplikacji webowej.

\paragraph{MailKit}

Do obsługi wysyłania wiadomości e-mail z aplikacji wykorzystano bibliotekę
MailKit. Jest to nowoczesne i wydajne narzędzie do obsługi protokołów SMTP,
POP3 i IMAP w środowisku \.NET\@. MailKit oferuje szeroki zakres funkcji,
takich jak tworzenie i wysyłanie wiadomości e-mail, obsługa załączników,
szyfrowanie oraz autoryzacja. Biblioteka ta jest znana ze swojej wydajności i
niezawodności, co czyni ją idealnym wyborem do integracji funkcji e-mail w
aplikacjach webowych.

\paragraph{DataProtection}

Do zapewnienia trwałości kluczy kryptograficznych wykorzystano bibliotekę
ASP.NET Core Data Protection. Dzięki integracji z Entity Framework Core, klucze
są przechowywane w bazie danych, co zapewnia ich persystencję między restartami
aplikacji, umożliwiając zachowanie sesji użytkowników i likwidując wymóg
ponownego logowania po restarcie serwera.

\paragraph{QuestPDF}

Do generowania dokumentów PDF w aplikacji wykorzystano bibliotekę QuestPDF\@.
Jest to nowoczesne narzędzie do tworzenia wysokiej jakości dokumentów PDF w
środowisku \.NET\@. QuestPDF oferuje prosty i intuicyjny interfejs
programistyczny, który umożliwia definiowanie układu i stylu dokumentów za
pomocą kodu C\#. Biblioteka obsługuje różnorodne funkcje, takie jak dodawanie
tekstu, obrazów, tabel i wykresów, co pozwala na tworzenie profesjonalnie
wyglądających raportów i dokumentów bez konieczności korzystania z zewnętrznych
narzędzi do edycji PDF\@.

Narzędzie QuestPDF zostało wykorzystane na licencji Community MIT, która
pozwala na darmowe użycie biblioteki w projektach niekomercyjnych i
komercyjnych, generujących dochód poniżej \$1,000,000 rocznie.

\subsubsection{Microsoft SQL Server 2022}

Aplikacja korzysta z relacyjnej bazy danych Microsoft SQL Server 2022 do
przechowywania wszystkich danych niezbędnych do jej funkcjonowania. Komunikacja
pomiędzy aplikacją a bazą danych odbywa się za pośrednictwem opisanego wyżej
Entity Framework Core, który umożliwia mapowanie obiektów C\# na tabele i
rekordy w bazie danych. Dodatkowo z bazą danych komunikują się narzędzia
ASP.NET Core Identity oraz Data Protection (poprzez integrację z EF Core).

\subsubsection{Traefik}

W środowisku produkcyjnym do zarządzania ruchem sieciowym i obsługi
certyfikatów SSL/TLS wykorzystano narzędzie Traefik\@. Jest to nowoczesny i
wydajny reverse proxy oraz load balancer, który automatycznie wykrywa usługi i
konfiguruje trasowanie ruchu na podstawie reguł zdefiniowanych przez
użytkownika. Traefik zintegrowany jest z Dockerem, co umożliwia dynamiczne
zarządzanie ruchem sieciowym w środowiskach kontenerowych. Dodatkowo, Traefik
oferuje wbudowaną obsługę Let's Encrypt, co pozwala na automatyczne generowanie
i odnawianie certyfikatów SSL/TLS, zapewniając bezpieczną komunikację między
klientami a serwerem.

\subsection{Ciągła integracja i dostarczanie (CI/CD)}
\label{sec:ci_cd_opis_technologii}

Główna część aplikacji została objęta konteneryzacją przy użyciu narzędzia
Docker. Konteneryzacja pozwala na zapakowanie aplikacji wraz ze wszystkimi jej
zależnościami w odizolowane środowisko, co umożliwia łatwe wdrożenie i dalsze
utrzymanie. Dodatkowo za pomocą pliku Dockerfile zdefiniowano proces budowania
obrazu kontenera od podstaw, co zapewnia spójność środowiska uruchomieniowego
aplikacji niezależnie od miejsca jej wdrożenia.

Wraz z kontenerem aplikacji ASP.NET Core przy pomocy narzędzia orkiestracji
kontenerów Docker Compose można w prosty sposób uruchomić również kontener bazy
danych Microsoft SQL Server 2022 oraz (w środowisku produkcyjnym) kontener
Traefik, jednocześnie konfigurując ich współpracę, sieć wewnętrzną oraz
wolumeny do trwałego przechowywania danych.

\subsection{Testy}

\todo{Zrobić testy XD}

\subsection{Zarządzanie kodem źródłowym}

Kod źródłowy aplikacji jest przechowywany w repozytorium Git na platformie
GitHub. Wykorzystano funkcje zarządzania wersjami, takie jak gałęzie i pull
requesty, aby umożliwić współpracę zespołową (w przyszłości) oraz śledzenie
zmian w kodzie. Dodatkowo, repozytorium zawiera dokumentację projektu,
instrukcje dotyczące wdrożenia oraz konfiguracji środowiska deweloperskiego.

\subsection{Narzędzia modelowania diagramów}

Do tworzenia diagramów UML oraz innych wizualizacji na potrzeby tej pracy użyto
dwóch narzędzi:

\begin{itemize}
      \item Structurizr --- do tworzenia diagramów architektury oprogramowania (C4 Model),
      \item Visual Paradigm (w wersji Community) --- do tworzenia pozostałych diagramów
            (np.\ modelu danych).
\end{itemize}

\section{Modele danych}

Poniżej przedstawiono dwa diagramy. Pierwszy odpowiada modelowi dziedzinowemu,
reprezentującemu główne pojęcia oraz ich relacje w kontekście logiki aplikacji.
Drugi odnosi się do modelu obiektowego, który odwzorowuje strukturę encji EF
Core, tym samym determinujących strukturę bazy danych.

\subsection{Model pojęciowy}

Zaprezentowany diagram modelu pojęciowego (rys. \ref{fig:model_pojęciowy})
ilustruje główne pojęcia oraz ich wzajemne relacje w kontekście logiki
aplikacji. Model ten stanowi abstrakcyjną reprezentację struktur danych i
zależności między nimi, niezależnie od konkretnej implementacji technicznej.

Całość modelu mieści się w logicznych granicach jednej \textbf{parafii} —
wymienione pojęcia odnoszą się do zarządzania kolędą w obrębie konkretnej
parafii, a tym samym do jednej domeny aplikacji.

\begin{figure}[h]
      \centering
      \includegraphics[width=\textwidth]{figures/Model pojęciowy.png}
      \caption{Model pojęciowy aplikacji}
      \label{fig:model_pojęciowy}
\end{figure}

\subsubsection{Personel}
Personel parafialny składa się z różnych ról, które mają określone uprawnienia
i obowiązki w kontekście zarządzania kolędą. Główne role to:
\begin{itemize}
      \item \textbf{Administrator} — osoba odpowiedzialna za zarządzanie
            aplikacją, w tym tworzenie i modyfikowanie planów kolędy oraz
            zarządzanie użytkownikami.
      \item \textbf{Ksiądz} — duchowny, który odwiedza parafian podczas kolędy.
            Może zarządzać danym planem i planować wizyty.
      \item \textbf{Ministrant} — osoba, która towarzyszy księdzu podczas wizyt.
            Może być przypisana do konkretnych agend w planie kolędy i na bieżąco
            aktualizować status wizyt.
\end{itemize}

\subsubsection{Plan}
Najbardziej ogólnym pojęciem w zakresie planowania kolędy jest \textbf{Plan}.
Reprezentuje on konkretny plan kolędy dla danego roku. Planów może być wiele,
są zarządzane przez parafialnego administratora aplikacji.

\subsubsection{Harmonogram}
Każdy plan kolędy musi zawierać przynajmniej jeden \textbf{Harmonogram}.
Harmonogramy umożliwiają podział zgłoszeń parafian na różne grupy, które z
kolei mogą służyć do filtrowania zgłoszeń, a także do tworzenia odrębnych
planów wizyt dla różnych księży. Przykładowo można za ich pomocą rozdzielić
kolędę w terminie zasadniczym od kolędy dodatkowej.

\subsubsection{Dzień}
Każdy plan składa się z wielu \textbf{Dni}, które reprezentują konkretne dni w
trakcie trwania kolędy.

\subsubsection{Agenda}
Każdy dzień zawiera wiele \textbf{Agend}, które grupują i porządkują wizyty
danego dnia. Każda agenda jest przypisana do konkretnego dnia i zawiera
informacje o ministrantach towarzyszących podczas wizyt. Agendy są
odpowiednikiem list wizyt, które ksiądz i ministranci realizują w danym dniu
kolędy. W najprostszym rozumieniu mogą służyć więc jako podział wizyt na
księdza pierwszego, drugiego, itd.

\subsubsection{Wizyta}
Podstawowym elementem planu kolędy jest \textbf{Wizyta}. Reprezentuje ona
konkretną wizytę księdza u parafianina. Wizyta może być przypisana do
konkretnej agendy, a tym samym być zaplanowana na konkretny dzień. Kolejność
wizyt w agendzie jest wyznaczana przez liczbę porządkową wizyty. Zasadniczo
przypisana jest też do konkretnego harmonogramu.

\subsubsection{Zgłoszenie, zgłaszający i adres}
Każda wizyta jest powiązana z konkretnym \textbf{Zgłoszeniem} parafianina.
Zgłoszenie zawiera wszystkie niezbędne informacje o parafianinie, takie jak
dane kontaktowe oraz adres zamieszkania (w powiązanych pojęciach). Do
zgłoszenia można dołączyć także dodatkowe uwagi (np. prośby dotyczące wizyty
lub preferencje dotyczące terminu).

\subsection{Model obiektowy}
\label{sec:model_obiektowy}

Poniżej zaprezentowano dwa diagramy modelu obiektowego aplikacji. Pierwszy z
nich (rys.\ \ref{fig:model_obiektowy_centralny}) odnosi się do kontekstu
ogólnego (centralnego), tj. do logiki zarządzania użytkownikami (docelowo w
różnych domenach — parafiach). Drugi (rys.\
\ref{fig:model_obiektowy_parafialny}) przedstawia model obiektowy funkcjonujący
w obrębie konkretnej domeny (kontekst parafialny).

\subsubsection{Kontekst centralny}

\begin{figure}[h]
      \centering
      \includegraphics[width=\textwidth]{figures/Model obiektowy - centralny.png}
      \caption{Model obiektowy aplikacji (kontekst centralny)}
      \label{fig:model_obiektowy_centralny}
\end{figure}

W kontekście centralnym aplikacji zajęto się zarządzaniem użytkownikami oraz
ich rolami w różnych domenach (parafiach). Główne klasy w tym modelu to
\textbf{User}, \textbf{Role} oraz \textbf{ParishEntry}.

\paragraph{User}
Reprezentuje użytkownika aplikacji. Zawiera podstawowe informacje o nim, w
większości dziedziczone z klasy \texttt{IdentityUser} z ASP.NET Core Identity.
Jest przypisany do konkretnej parafii.

Najważniejsze pola klasy \texttt{User} to:
\begin{itemize}
      \item \texttt{UserName} — login użytkownika,
      \item \texttt{Email} — adres e-mail użytkownika,
      \item \texttt{PasswordHash} — hash hasła użytkownika,
      \item \texttt{DisplayName} — nazwa użytkownika.
\end{itemize}

\paragraph{Role}
Reprezentuje role użytkowników w aplikacji. Każda rola definiuje zestaw
uprawnień i obowiązków, które użytkownik posiada w kontekście zarządzania
kolędą.

\texttt{Role} jest enumeracją o następujących wartościach:
\begin{itemize}
      \item \textbf{DefaultUser} — uprawnia do podstawowego dostępu do aplikacji,
      \item \textbf{VisitSupport} — uprawnia do przeprowadzania wizyt
            kolędowych (odpowiednik ministranta),
      \item \textbf{SubmitSupport} — uprawnia do wprowadzania zgłoszeń i zarządzania nimi,
      \item \textbf{Priest} — uprawnia do wszystkich powyższych czynności oraz do
            planowania wizyt,
      \item \textbf{Administrator} — uprawnia do zarządzania aplikacją i wszystkimi
            jej funkcjami.
\end{itemize}

\paragraph{ParishEntry}
Reprezentuje rzeczywistą parafię, która używa aplikacji do zarządzania kolędą.
Do każdej jest przypisany przynajmniej jeden użytkownik.

Najważniejsze pola klasy \texttt{ParishEntry} to:
\begin{itemize}
      \item \texttt{UniqueId} — unikalny identyfikator parafii,
      \item \texttt{ParishName} — nazwa parafii,
      \item \texttt{EncryptedConnectionString} — zaszyfrowany łańcuch połączenia do bazy danych parafii,
      \item \texttt{CreationTime} — data utworzenia parafii w systemie.
\end{itemize}

\subsubsection{Kontekst parafialny}

Kontekst parafialny zbiera wszystkie klasy związane z zarządzaniem kolędą w
obrębie konkretnej parafii. Główne klasy w tym modelu to \textbf{Plan},
\textbf{Schedule}, \textbf{Day}, \textbf{Agenda}, \textbf{Submission} oraz
\textbf{Visit}.

W tym modelu wyróżniają się dwie najistotniejsze grupy encji (w podziale
funkcjonalnym): encje służące do \textit{Przyjmowania zgłoszeń} i do
\textit{Planowania wizyt}. Wszystkie opisane są poniżej.

\paragraph{\textit{Przyjmowanie zgłoszeń}}

\paragraph{Submission}
Reprezentuje zgłoszenie na kolędę. Zawiera wszystkie niezbędne informacje o
parafianinie, takie jak dane kontaktowe oraz adres zamieszkania (w powiązanych
klasach).

Najważniejsze pola klasy \texttt{Submission} to:
\begin{itemize}
      \item \texttt{SubmitterNotes} — dodatkowe uwagi (od zgłaszającego do administratora),
      \item \texttt{AdminMessage} — informacja systemowa (od administratora do zgłaszającego),
      \item \texttt{AdminNotes} — wewnętrzne notatki (widoczne tylko dla zalogowanych użytkowników),
      \item \texttt{NotesStatus} — status realizacji dodatkowych uwag (np.\ oczekujące, zrealizowane).
\end{itemize}

\paragraph{Submitter}
Reprezentuje parafianina, który składa zgłoszenie na kolędę. Jest bezpośrednio
powiązany ze zgłoszeniem (lub wieloma).

Najważniejsze pola klasy \texttt{Submitter} to:
\begin{itemize}
      \item \texttt{Name} — imię zgłaszającego,
      \item \texttt{Surname} — nazwisko zgłaszającego,
      \item \texttt{PhoneNumber} — numer telefonu zgłaszającego,
      \item \texttt{Email} — adres e-mail zgłaszającego.
\end{itemize}

\paragraph{Address}
Reprezentuje adres zamieszkania parafianina. Jest bezpośrednio powiązany ze
zgłoszeniem (w relacji \textit{1 do 1} z dokładnością do konkretnego planu
kolędy). Jest on prawie w całości zatomizowany, aby ujednolicić format adresów,
podawanych w formularzu zgłoszeniowym (by zachować jednoznaczność).

Jest powiązany z szeregiem klas pomocniczych, które reprezentują poszczególne
elementy adresu (np.\ budynek (brama), ulica, miasto).

Najważniejsze pola klasy \texttt{Address} to:
\begin{itemize}
      \item \texttt{ApartmentNumber} — numer mieszkania,
      \item \texttt{ApartmentLetter} — litera mieszkania (opcjonalnie, raczej rzadko),
      \item właściwości \textit{cache} — kopia tekstowa właściwości z klas pomocniczych
            (dla przyspieszenia operacji bazodanowych),
      \item \texttt{FilterableString} — znormalizowany łańcuch znaków do celów filtrowania
            i wyszukiwania adresów (\textit{computed} — obliczony przez bazę danych na
            podstawie pól \textit{cache}).
\end{itemize}

\subparagraph{Building}
Reprezentuje budynek (bramę) w adresie zamieszkania parafianina. Każdy budynek
może mieć wiele adresów (mieszkań). Jest tworzony przez administratora parafii
i wybierany z listy w formularzu zgłoszeniowym (i kilku innych miejscach).

Najważniejsze pola klasy \texttt{Building} to:
\begin{itemize}
      \item \texttt{Number} — numer budynku,
      \item \texttt{Letter} — litera budynku (opcjonalnie),
      \item \texttt{FloorCount} — liczba pięter w budynku (opcjonalnie, do celów
            statystycznych),
      \item \texttt{ApartmentCount} — liczba mieszkań w budynku (opcjonalnie,
            do celów statystycznych),
      \item \texttt{HighestApartmentNumber} — najwyższy numer mieszkania w
            budynku (opcjonalnie, do celów statystycznych),
      \item \texttt{HasElevator} — czy budynek posiada windę (może mieć wpływ na
            planowanie wizyt),
      \item \texttt{AllowSelection} — czy budynek może być wybrany w formularzu
            zgłoszeniowym (w przeciwnym przypadku jest ukryty i może zostać wybrany
            tylko przez zalogowanego użytkownika).
\end{itemize}

\subparagraph{Street}
Reprezentuje ulicę w adresie zamieszkania parafianina. Każda ulica może mieć
wiele budynków. Podobnie jak budynek, jest tworzona przez administratora
parafii i wybierany z listy w formularzu zgłoszeniowym (i kilku innych
miejscach).

Najważniejsze pola klasy \texttt{Street} to:
\begin{itemize}
      \item \texttt{Name} — nazwa ulicy (bez tytułów typu ulica, aleja, plac itd.),
      \item \texttt{PostalCode} — kod pocztowy ulicy (opcjonalnie).
\end{itemize}

\subparagraph{StreetSpecifier}
Reprezentuje typ ulicy (np.\ ulica, aleja, plac itd.). Każda ulica jest
powiązana z jednym \texttt{StreetSpecifier}, który określa jej typ. Podobnie
jak budynek i ulica, jest tworzony przez administratora parafii.

Najważniejsze pola klasy \texttt{StreetSpecifier} to:
\begin{itemize}
      \item \texttt{FullName} — pełna nazwa typu ulicy (np.\ ulica, aleja, plac itd.),
      \item \texttt{Abbreviation} — skrócona nazwa typu ulicy (np.\ ul., al., pl.).
\end{itemize}

\subparagraph{City}
Reprezentuje miasto w adresie zamieszkania parafianina. Każde miasto może mieć
wiele ulic. Podobnie jak powyższe klasy, jest tworzone przez administratora
parafii.

Najważniejsze pola klasy \texttt{City} to:
\begin{itemize}
      \item \texttt{Name} — pełna nazwa miasta,
      \item \texttt{DisplayName} — wyświetlana nazwa miasta.
\end{itemize}

\paragraph{\textit{Planowanie wizyt}}

\begin{figure}[h]
      \centering
      \includegraphics[width=\textwidth]{figures/Model obiektowy - parafia.png}
      \caption{Model obiektowy aplikacji (kontekst parafialny)}
      \label{fig:model_obiektowy_parafialny}
\end{figure}

\paragraph{Visit}
Jest odpowiednikiem zgłoszenia w kontekście planowania wizyt. Reprezentuje
konkretną wizytę księdza u parafianina. Jest powiązana z danym zgłoszeniem w
relacji \textit{1 do 1}, w ten sposób są ze sobą ściśle powiązane.

Najważniejsze pola klasy \texttt{Visit} to:
\begin{itemize}
      \item \texttt{OrdinalNumber} — liczba porządkowa wizyty w agendzie,
      \item \texttt{Status} — status wizyty (np.\ zaplanowana, zaakceptowana,
            odrzucona),
      \item \texttt{PeopleCount} — liczba domowników uczestniczących w wizycie
            (do celów statystycznych).
\end{itemize}

\paragraph{Plan}
Reprezentuje plan wizyt kolędowych (najczęściej na dany rok). Zawiera wiele
dni, które z kolei zawierają agendy i wizyty. Jest zarządzany przez
parafialnego administratora aplikacji. Można przypisać do niego księży, którzy
będą w nim występować.

Najważniejsze pola klasy \texttt{Plan} to:
\begin{itemize}
      \item \texttt{Name} — nazwa planu,
      \item \texttt{CreationTime} — czas utworzenia planu.
\end{itemize}

\paragraph{Schedule}
Reprezentuje harmonogram wizyt w planie kolędy. Służy do podziału zgłoszeń
parafian na różne grupy, np.\ na kolędę w terminie i kolędę dodatkową. Każdy
plan musi zawierać przynajmniej jeden harmonogram.

Najważniejsze pola klasy \texttt{Schedule} to:
\begin{itemize}
      \item \texttt{Name} — nazwa harmonogramu,
      \item \texttt{ShortName} — skrócone oznaczenie harmonogramu,
      \item \texttt{Color} — kolor harmonogramu (zapisany w formacie szesnastkowym
            z poprzedzającym znakiem \#).
\end{itemize}

\paragraph{Day}
Reprezentuje konkretny dzień w trakcie trwania kolędy. Zawiera wiele agend,
które grupują wizyty danego dnia.

Najważniejsze pola klasy \texttt{Day} to:
\begin{itemize}
      \item \texttt{Date} — data dnia,
      \item \texttt{StartHour} — godzina rozpoczęcia kolędy w danym dniu,
      \item \texttt{EndHour} — godzina zakończenia kolędy w danym dniu.
\end{itemize}

\paragraph{Agenda}
Reprezentuje listę wizyt w konkretnym dniu kolędy. Każda agenda jest przypisana
do konkretnego dnia i można do niej przypisywać księdza oraz ministrantów.
Porządek wizyt w agendzie jest wyznaczany przez liczbę porządkową wizyty.

Najważniejsze pola klasy \texttt{Agenda} to:
\begin{itemize}
      \item \texttt{StartHourOverride} — godzina rozpoczęcia kolędy
            dla danej agendy (opcjonalnie, nadpisuje godzinę z dnia),
      \item \texttt{EndHourOverride} — godzina zakończenia kolędy
            dla danej agendy (opcjonalnie, nadpisuje godzinę z dnia),
      \item \texttt{GatheredFunds} — suma zebranych funduszy podczas wizyt
            w danej agendzie,
      \item \texttt{HideVisits} — czy ukryć wizyty w danej agendzie przed
            parafianami (np.\ przed publikacją planu, przy tworzeniu szkicu),
      \item \texttt{ShowHours} — czy pokazywać parafianom przewidywane godziny
            ich wizyty (dopiero gdy plan jest zatwierdzony).
      \item \texttt{IsOfficial} — czy pokazywać i liczyć agendę w statystykach jako pełnoprawną
            (wizyty w niej liczą się bez względu na tę właściwość).
\end{itemize}

\paragraph{BuildingAssignment}
Reprezentuje przypisanie konkretnego budynku do konkretnego dnia w planie
kolędy (w ramach wybranego harmonogramu). Pozwala to na automatyczne
sugerowanie terminów wizyt dla każdego zgłoszenia (na podstawie adresu oraz
harmonogramu), a także automatyczny zapis przy rejestracji zgłoszenia.

Jedyne pole klasy \texttt{BuildingAssignment} to:
\begin{itemize}
      \item \texttt{EnableAutoAssign} — czy włączyć automatyczne przypisywanie
            wizyt dla danego budynku w danym dniu (dla danego budynku w danym
            harmonogramie tylko jeden dzień może mieć włączony auto-zapis).
\end{itemize}

\paragraph{\textit{Tworzenie historii zmian}}

Oprócz powyższych dwóch grup w modelu znajduje się również pięć klas
pomocniczych, służących do rejestrowania historii zmian dla wybranych encji
modelu. Trzy z nich to klasy typu \textit{snapshot}:
\textbf{SubmissionSnapshot}, \textbf{SubmitterSnapshot} oraz
\textbf{VisitSnapshot}. Przechowują one kopię stanu odpowiadającej im encji w
momencie dokonania zmiany wraz z informacją o autorze zmiany. Czwarta klasa to
\textbf{FormSubmission}, która zachowuje kopię oryginalnych danych zgłoszenia
(w momencie wprowadzenia do systemu). Pozwala na odtworzenie pierwotnej wersji
zgłoszenia w przypadku nadużyć lub problemów. Ostatnia klasa to
\textbf{EmailLog}, która rejestruje wysyłane wiadomości e-mail z aplikacji,
wraz z ich zawartością i odbiorcami. Pozwala to na audyt i śledzenie
komunikacji prowadzonej przez system, a także na ponawianie próby wysyłania
wiadomości (gdy serwer pocztowy był niedostępny itp.).

\paragraph{\textit{Zarządzanie parafią}}

W modelu znajdują się również dwie encje do zarządzania informacjami dot.\
parafii: \textbf{ParishMember} oraz \textbf{ParishInfo}.

Pierwsza z nich reprezentuje użytkownika systemu, odpowiadającego dokładnie
jednemu użytkownikowi z kontekstu centralnego (klasa \texttt{User}) poprzez
pole \texttt{CentralUserId}. Podczas gdy do celów zarządzania użytkownikami i
pobierania ich informacji służy klasa \texttt{User} w kontekście centralnym, to
klasa \texttt{ParishMember} pozwala na tworzenie relacji między użytkownikami
(reprezentowanymi przez nią w kontekście parafii) a innymi encjami, np.\ planem
kolędy (przypisanie księży do planu) lub agendą (przypisanie ministrantów do
agendy).

Druga z nich jest prostym magazynem dla wszelakich informacji (w tym tych o
parafii), które mogą być potrzebne w aplikacji, ale nie mają dedykowanej encji
w modelu. Składa się z par klucz-wartość, gdzie klucz jest unikalnym
identyfikatorem informacji, a wartość przechowuje jej treść.

\paragraph{\textit{Typy wyliczeniowe}}

W modelu zastosowano również kilka typów wyliczeniowych (\textit{enum}'ów),
które służą do definiowania stałych wartości dla określonych właściwości encji.

\subparagraph{SubmitMethod}
Określa metodę, za pomocą której parafianin złożył zgłoszenie na kolędę.
Dostępne wartości to:
\begin{itemize}
      \item \textbf{NotRegistered} — nie zarejestrowano (domyślnie),
      \item \textbf{PaperForm} — formularz papierowy,
      \item \textbf{WebForm} — formularz internetowy,
      \item \textbf{Phone} — telefonicznie,
      \item \textbf{Stationary} — osobiście (np.\ w kancelarii parafialnej),
      \item \textbf{Email} — mailowo,
      \item \textbf{DuringVisit} — osobiście podczas sąsiednich wizyt danego dnia.
\end{itemize}

\subparagraph{NotesFulfillmentStatus}
Określa status realizacji dodatkowych uwag przez personel parafii. Dostępne
wartości to:
\begin{itemize}
      \item \textbf{NA} — nie dotyczy (domyślnie, gdy brak uwag),
      \item \textbf{Pending} — oczekujące (domyślnie gdy są uwagi),
      \item \textbf{Rejected} — niezrealizowane,
      \item \textbf{Accepted} — zrealizowane.
\end{itemize}

\subparagraph{VisitStatus}
Określa status wizyty kolędowej. Dostępne wartości to:
\begin{itemize}
      \item \textbf{Unplanned} — niezaplanowana (domyślnie),
      \item \textbf{Planned} — zaplanowana (w agendzie),
      \item \textbf{Pending} — trwająca,
      \item \textbf{Visited} — zrealizowana (odbyta),
      \item \textbf{Rejected} — nieodbyta (np.\ parafianin nie otworzył drzwi),
      \item \textbf{Withdrawn} — wycofana (np.\ parafianin wycofał zgłoszenie),
      \item \textbf{Suspended} — wstrzymana (w szczególnych okolicznościach,
            stan tymczasowy podczas przeprowadzania wizyt).
\end{itemize}

\section{Architektura}

\subsection{Poziom I — diagram kontekstowy systemu}

Architektura aplikacji została zaprezentowana poniżej z użyciem modelu C4. Jego
najwyższy poziom (\textit{System Context Diagram}, rys.
\ref{fig:c4_system_context_diagram}) przedstawia ogólny widok na system oraz
jego interakcje z użytkownikami i zewnętrznymi systemami.

\begin{figure}[h]
      \centering
      \includegraphics[width=\textwidth]{figures/SYS_Diagram SOK.png}
      \caption{Diagram kontekstowy systemu}
      \label{fig:c4_system_context_diagram}
\end{figure}

W naszym przypadku głównym komponentem jest aplikacja webowa \textbf{SOK}.
Umożliwia ona zarządzanie kolędą w parafiach poprzez interfejs użytkownika
dostępny z poziomu przeglądarki internetowej. Aplikacja komunikuje się
dodatkowo z serwerem pocztowym (do wysyłania powiadomień e-mail).

Na diagramie zaznaczono również dwóch aktorów: \textbf{Parafianina} oraz
\textbf{Personel parafialny}. Parafianin może składać zgłoszenia na kolędę oraz
przeglądać swój panel zgłoszenia (wszystko jako anonimowy użytkownik). Personel
parafialny zarządza zgłoszeniami i planuje wizyty kolędowe.

\subsection{Poziom II — diagram kontenerów}

Drugi poziom modelu C4 (\textit{Container Diagram}, rys.
\ref{fig:c4_container_diagram}) przedstawia główne kontenery aplikacji oraz ich
interakcje.

\begin{figure}[h]
      \centering
      \includegraphics[width=\textwidth]{figures/CON_Diagram SOK.png}
      \caption{Diagram kontenerów aplikacji}
      \label{fig:c4_container_diagram}
\end{figure}

Na tym poziomie widzimy rozróżnienie między personelem a parafianinami.
Personel, odwiedzając aplikację webową, korzysta z pełnego interfejsu
użytkownika, który udostępnia wszystkie funkcje aplikacji (w granicach roli).
Parafianin natomiast korzysta z \textit{widoków publicznych}, które są dostępne
bez logowania. W dalszej części pracy odnosząc się do \textit{widoku} będziemy
mieli na myśli interfejs użytkownika zalogowanego.

Widok aplikacji webowej może również korzystać z API, które udostępnia wybrane
funkcje aplikacji w formie usług sieciowych (por.\ rozdział
\ref{sec:vue_opis}). Aplikacja API, tak samo jak główny komponent aplikacji,
komunikuje się z bazą danych oraz z serwerem pocztowym.

\subsection{Poziom III — diagram komponentów}

\subsubsection{Aplikacja webowa}

\begin{figure}[h!]
      \centering
      \includegraphics[width=\textwidth]{figures/COM_Diagram WebApp.png}
      \caption{Diagram komponentów aplikacji webowej}
      \label{fig:c4_component_diagram_web_app}
\end{figure}

Aplikacja webowa jest zaprogramowana w architekturze MVC
(Model-View-Controller). Podział ten widoczny jest na diagramie (rys.
\ref{fig:c4_component_diagram_web_app}), choć nie jest wyraźny przy pierwszej
analizie z powodu dodatkowych komponentów, które zostały zaprezentowane ze
względu na ich istotną rolę w aplikacji.

\paragraph{Kontrolery}

Pierwszym rodzajem komponentu jest \textbf{Kontroler}, który obsługuje żądania
HTTP od użytkowników i koordynuje przepływ danych między modelem a widokiem. W
aplikacji znajdują się dwa rodzaje kontrolerów: kontrolery aplikacji (dla
personelu parafialnego) oraz kontrolery publiczne (dla parafian).

Pierwszy z nich obsługuje wszystkie funkcje aplikacji dostępne dla zalogowanych
użytkowników (w granicach ich ról). Korzysta przy tym z komponentu do
autoryzacji, aby sprawdzić uprawnienia użytkownika przed wykonaniem danej
akcji. Drugi z nich obsługuje funkcje dostępne bez logowania, tj.\ składanie
zgłoszeń na kolędę oraz przeglądanie panelu zgłoszenia.

\paragraph{Widoki}

Kolejnym rodzajem komponentu są \textbf{Widoki}, które zawierają interfejs
użytkownika aplikacji, prezentowany w przeglądarce. Widoki są tworzone przy
użyciu technologii Razor, która umożliwia dynamiczne generowanie stron HTML na
podstawie danych z modelu. Podobnie jak kontrolery, podzielone są na dwie
kategorie: widoki dla zalogowanych użytkowników oraz widoki publiczne dla
parafian.

Podczas gdy widoki publiczne są prostsze i bardziej statyczne (głównie
formularze i strony informacyjne), widoki dla zalogowanych użytkowników są
często bardziej rozbudowane i interaktywne, oferując zaawansowane funkcje
zarządzania kolędą. W sekcji \ref{sec:frontend_opis} opisano podejścia
wykorzystane do tworzenia interfejsu użytkownika w widokach aplikacji webowej.

\paragraph{Modele}

W architekturze MVC modele są przekazywane z kontrolerów do widoków, aby
prezentować dane użytkownikowi. W opisywanej aplikacji jest to każdorazowo
realizowane za pomocą jednego ze specjalnych typów modeli:

\begin{itemize}
      \item \textbf{ViewModels} (\textit{modele widoków}) — specjalne modele
            zaprojektowane do reprezentowania danych w widokach. Mogą zawierać
            dodatkową logikę prezentacyjną lub formatowanie danych.
      \item \textbf{DTO (Data Transfer Objects)} — proste obiekty, pochodzące
            bezpośrednio z warstwy aplikacji (por.\ sekcja \ref{sec:warstwa_aplikacji}),
            które często są wystarczające do prezentacji danych.
      \item \textbf{Encje EF Core} — bezpośrednie modele danych z warstwy
            domeny. Stosowane głównie w prostych widokach, gdzie nie jest wymagana
            dodatkowa logika prezentacyjna.
\end{itemize}

\paragraph{Logika biznesowa}

Logika biznesowa aplikacji jest zaimplementowana w warstwie aplikacji (por.\
sekcja \ref{sec:warstwa_aplikacji}) i jest wykorzystywana przez kontrolery
aplikacji przy użyciu \textbf{Serwisów aplikacji}, reprezentowanych na
diagramie (rys. \ref{fig:c4_component_diagram_web_app}) przez komponent
\textit{Usługi}. Serwisy aplikacji zawierają metody do wykonywania operacji
biznesowych, takich jak zarządzanie zgłoszeniami, planowanie wizyt czy
wysyłanie powiadomień e-mail. Kontrolery aplikacji nigdy nie komunikują się
bezpośrednio z warstwą domeny lub infrastrukturą, lecz zawsze poprzez serwisy
aplikacji.

\paragraph{Dostęp do danych}

Dostęp do danych w aplikacji jest realizowany za pomocą wzorca
\textbf{Repozytoriów}, które są reprezentowane na diagramie przez komponent
\textit{Repozytoria}. Repozytoria zapewniają abstrakcję nad warstwą dostępu do
danych, umożliwiając kontrolerom i serwisom aplikacji interakcję z bazą danych
bez konieczności bezpośredniego korzystania z ORM (Entity Framework Core).
Repozytoria zawierają metody do wykonywania operacji CRUD (tworzenie, odczyt,
aktualizacja, usuwanie) na encjach domeny.

Repozytoria również są zebrane w jednym komponencie. W tym przypadku jednak ma
to dodatkowy wymiar, ponieważ wszystkie one są dostępne poprzez jeden obiekt
\texttt{UnitOfWork}, który dodatkowo koordynuje transakcje i zapewnia spójność
danych.

\subsubsection{Aplikacja API}

\begin{figure}[htbp]
      \centering
      \includegraphics[width=\textwidth]{figures/COM_Diagram ApiApp.png}
      \caption{Diagram komponentów aplikacji API}
      \label{fig:c4_component_diagram_api_app}
\end{figure}

Aplikacja API działa w podobny sposób jak aplikacja webowa, jednak jej głównym
celem jest udostępnianie funkcji aplikacji w formie usług sieciowych
(dostępnych poprzez protokół HTTP). Diagram komponentów aplikacji API został
zaprezentowany na rys. \ref{fig:c4_component_diagram_api_app}.

Podobnie jak w aplikacji webowej, głównymi komponentami są tutaj
\textbf{Kontrolery}, \textbf{Serwisy aplikacji} oraz \textbf{Repozytoria}.
Kontrolery API obsługują żądania HTTP od klientów API (widoków aplikacji) i
wykonują operacje biznesowe za pomocą serwisów aplikacji. Serwisy aplikacji i
repozytoria działają identycznie jak w aplikacji webowej, zapewniając
abstrakcję nad logiką biznesową i dostępem do danych. Jedyną istotną różnicą
jest brak części publicznej, ponieważ aplikacja API jest przeznaczona wyłącznie
do użytku przez widoki aplikacji webowej dla zalogowanych użytkowników.

Aplikacja API udostępnia jedynie wybrane funkcje aplikacji, które bezpośrednio
wspierają interfejs użytkownika. Z tego powodu nie wszystkie serwisy aplikacji
i repozytoria są dostępne poprzez API.\@ Również punkty końcowe często są
dostępne tylko poprzez niektóre metody HTTP (spośród GET, POST, PUT, PATCH,
DELETE).

\section{DDD i warstwy systemu}
\label{sec:architektura_warstwowa}

Aplikację zaprojektowano i zaimplementowano w podejściu Domain-Driven Design
(DDD), tworząc warstwową architekturę, która składa się z następujących
poziomów:

\begin{itemize}
      \item Warstwa domeny (Domain Layer)
      \item Warstwa aplikacji (Application Layer)
      \item Warstwa infrastruktury (Infrastructure Layer)
      \item Warstwa interfejsu użytkownika (UI Layer)
\end{itemize}

Każdy z nich jest odpowiedzialny za określone aspekty aplikacji i komunikuje
się z innymi warstwami w sposób jasno zdefiniowany.

\subsection{Warstwa domeny}
\label{sec:warstwa_domeny}

Najniższą warstwą w architekturze jest \textbf{Warstwa domeny}, która zawiera
wszystkie elementy związane z modelem domeny aplikacji. Umieszczone zostały
tutaj głównie encje domenowe (por. \ref{sec:model_obiektowy}). Warstwa domeny
jest niezależna od innych warstw i nie zawiera żadnych odwołań do technologii
zewnętrznych (np.\ baz danych, frameworków webowych itp.).

\subsection{Warstwa aplikacji}
\label{sec:warstwa_aplikacji}

\textbf{Warstwa aplikacji} znajduje się powyżej warstwy domeny i jest odpowiedzialna
za implementację logiki biznesowej aplikacji. Zawiera serwisy aplikacji, które
realizują operacje biznesowe, korzystając z encji domeny. Warstwa aplikacji
komunikuje się z warstwą domeny poprzez bezpośrednie odwołania do encji oraz z
warstwą infrastruktury poprzez repozytoria. Jest wykorzystywana przez warstwę
interfejsu użytkownika i najczęściej przekazuje do niej dane w formie DTO (Data
Transfer Objects).

\subsection{Warstwa infrastruktury}
\label{sec:warstwa_infrastruktury}

\textbf{Warstwa infrastruktury} zapewnia implementację techniczną dla aplikacji.
Zawiera realizację repozytoriów, które umożliwiają dostęp do bazy danych
oraz inne komponenty infrastrukturalne, w tym komponent do wysyłania
wiadomości e-mail czy komponent autoryzacji. Główną odpowiedzialnością
warstwy infrastruktury jest izolowanie pozostałych warstw od szczegółów technicznych,
takich jak konkretna baza danych czy protokoły komunikacyjne.

\subsection{Warstwa UI}
\label{sec:warstwa_ui}

Najwyższym poziomem w architekturze jest \textbf{Warstwa interfejsu
      użytkownika}, która zawiera komponenty odpowiedzialne za interakcję z
użytkownikami. W naszym przypadku są to aplikacja webowa oraz aplikacja API.\@
Warstwa UI komunikuje się z warstwą aplikacji, korzystając z serwisów aplikacji
i przekazuje dane do prezentacji użytkownikowi do widoków.

\section{Architektura wdrażania}
\label{sec:architektura_wdrazania}

Jak wspomniano w sekcji \ref{sec:ci_cd_opis_technologii} aplikacja została
zaopatrzona w stosowny plik \texttt{Dockerfile}, który pozwala na zbudowanie
obrazu aplikacji. Na jego podstawie można następnie tworzyć kontenery Dockera.

W projekcie umieszczono również plik \texttt{docker-compose.yml} (wraz z
kilkoma odmianami), który pozwala na uruchomienie całego środowiska aplikacji
(z aplikacją, bazą danych i menadżerem ruchu) za pomocą jednego polecenia z
uwzględnieniem opcji konfiguracyjnych za pomocą orkiestratora Docker Compose.

\begin{figure}[h]
      \centering
      \includegraphics[width=\textwidth]{figures/DPL_Diagram SOK.png}
      \caption{Diagram wdrażania aplikacji}
      \label{fig:deployment_diagram}
\end{figure}

Na diagramie wdrażania (rys. \ref{fig:deployment_diagram}) zaprezentowano
strukturę środowiska aplikacji. Zaznaczone są na nim trzy wyżej wymienione
usługi: aplikacja webowa, baza danych oraz menadżer ruchu (reverse proxy).

\subsubsection{Konteneryzacja}

Wszystkie trzy usługi są uruchamiane w oddzielnych kontenerach Dockera, co
pozwala na ich izolację i łatwe zarządzanie. Konteneryzacja umożliwia również
łatwe skalowanie aplikacji oraz przenoszenie jej między różnymi środowiskami
(deweloperskim, testowym, produkcyjnym).

Przy zmianach w kodzie aplikacji lub jej konfiguracji wystarczy więc zbudować
nowy obraz Dockera i uruchomić nowy kontener. Zachowuje się w ten sposób
izolację od bazy danych, która nie odnotowuje żadnych przerw w działaniu.

\subsubsection{Zarządzanie siecią}

W środowisku aplikacji zastosowano również wirtualną sieć Dockera, która
pozwala na zachowanie bezpośredniej komunikacji między kontenerami przy pełnej
ich izolacji od sieci zewnętrznej. Kontenery mogą się ze sobą komunikować za
pomocą nazw usług (np.\ \texttt{database} dla bazy danych), co upraszcza
konfigurację połączeń.

Jedynym punktem dostępu do aplikacji z zewnątrz jest menadżer ruchu, który
przekazuje żądania do aplikacji webowej. Pozwala to na dodatkowe zabezpieczenie
aplikacji oraz na łatwe zarządzanie ruchem sieciowym (np.\ poprzez konfigurację
certyfikatów SSL/TLS).

\subsubsection{Trwałość danych}

Baza danych jest skonfigurowana z użyciem wolumenu Dockera, który zapewnia
trwałość danych pomiędzy restartami kontenera. Oznacza to, że dane
przechowywane w bazie danych nie zostaną utracone w przypadku ponownego
uruchomienia kontenera lub aktualizacji aplikacji. Wolumen jest mapowany na
lokalny katalog na hoście, co pozwala na łatwe tworzenie kopii zapasowych i
zarządzanie danymi bazy.

\subsubsection{Środowisko produkcyjne}

Dzięki zastosowaniu powyższego zestawu technologii i podejść architektonicznych
aplikacja jest łatwa do wdrożenia i utrzymania na dowolnym serwerze
obsługującym Dockera, w szczególności na popularnych platformach chmurowych.
Nie jest jednak do nich ograniczone — cały stos technologiczny może być
uruchomiony na dowolnym serwerze fizycznym lub wirtualnym, do którego
użytkownik ma dostęp, za pomocą jednego polecenia (bez konieczności manualnego
konfigurowania środowiska — instalowania oprogramowania i jego zależności).

\section{Opis rozwiazania wybranych problemów }
\todo{Napisać}

\subsection{Dostęp do bazy danych}

W aplikacji ze względu na wielodomenowość (wzorzec \textit{multi-tenant})
zastosowano izolację danych na poziomie bazy danych. Oznacza to, że każda
parafia posiada oddzielną bazę danych, co zapewnia pełną separację danych
między parafiami i zwiększa bezpieczeństwo. Aby umożliwić aplikacji dostęp do
odpowiedniej bazy danych w zależności od parafii, zastosowano dynamiczne
tworzenie ciągów połączeń w kontekście \textit{EF Core}.

\subsubsection{Określenie parafii}

Pierwszym elementem mechanizmu uzyskiwania dostępu do odpowiedniej bazy danych
jest \textit{middleware} \texttt{ParishResolver}, umieszczone w potoku
przetwarzania. W nim pobierane są informacje o parafii (z ciasteczka lub
parametru adresu URL).

\subsubsection{Pobranie informacji o parafii}

Następnie \texttt{ParishResolver} korzysta z serwisu
\texttt{ICurrentParishService}, który umożliwia zapisywanie i pobieranie
informacji o aktualnie wybranej parafii w trakcie trwania żądania HTTP\@.
Serwis ten ma zasięg \textit{scoped}, dzięki czemu jego stan jest zachowywany
tylko w trakcie przetwarzania danego żądania.

Główną funkcją serwisu jest pobranie informacji o parafii z centralnej bazy
danych, odszyfrowanie ciągu połączenia i zapisanie go w swoim stanie. W ten
sposób pozostaje on dostępny dla pozostałych komponentów aplikacji w trakcie
przetwarzania żądania.

\subsubsection{Utworzenie kontekstu}

Po wykonaniu powyższych kroków następuje utworzenie kontekstu bazy danych
\texttt{ParishDbContext} w kontenerze \textit{DI}\@. Wtedy wywoływana jest
nadpisana metoda \texttt{OnConfiguring}, w której pobierany jest ciąg
połączenia z serwisu \texttt{ICurrentParishService} i konfigurowany jest
kontekst do korzystania z odpowiedniej bazy danych.

Dalej w aplikacji wszystkie operacje na bazie danych są wykonywane za pomocą
kontekstu \texttt{ParishDbContext}, który jest już poprawnie skonfigurowany do
komunikacji z bazą danych odpowiedniej parafii.

\subsection{Zarządzanie parafiami}

Ze względu na izolację danych na poziomie bazy danych, tworzenie nowej parafii
wymaga utworzenia nowej bazy danych oraz odpowiedniej jej konfiguracji,
włączając utworzenie użytkownika bazy i wykonanie wszystkich należnych
migracji. Aby zautomatyzować ten proces, w aplikacji zaimplementowano serwis
\texttt{IParishProvisioningService}, który wykonuje wszystkie niezbędne kroki.
Posiada on dwie metody publiczne: \texttt{CreateParishAsync} oraz
\texttt{EnsureAllParishDatabasesReadyAsync}.

Pierwsza z nich służy do utworzenia bazy danych na poziomie serwera baz danych
i jest wywoływana przy rejestracji nowej parafii. Druga z nich jest
wykorzystywana podczas uruchamiania aplikacji, sprawdzając, czy wszystkie bazy
danych parafii (zapisanych w centralnej bazie danych) są poprawnie
skonfigurowane i gotowe do użycia. Obie metody korzystają ze wspólnej metody
prywatnej, która działa w następujących krokach:

\begin{itemize}
      \item Połączenie z serwerem baz danych przy użyciu konta administracyjnego,
      \item Utworzenie nowej bazy danych o unikalnej nazwie (z losowym sufiksem),
      \item Utworzenie nowego użytkownika z unikalną nazwą (z losowym sufiksem) oraz
            przypisanie mu odpowiednich uprawnień do tej bazy danych,
      \item Wykonanie wszystkich (nowych) migracji Entity Framework Core na tej bazie
            danych,
      \item Zapisanie informacji o parafii w centralnej bazie danych, w tym zaszyfrowanego
            ciągu połączenia do tej bazy danych.
\end{itemize}

Gdy metoda ma utworzyć parafię, wszystkie kroki wykonają się bezwarunkowo, gdy
jednak służy do sprawdzenia istnienia bazy danych, to pomija adekwatne kroki w
razie braku konieczności ich wykonania.

W ten sposób proces tworzenia parafii jest w pełni zautomatyzowany i nie wymaga
ręcznej interwencji administratora bazy danych. Używa przy tym niskopoziomowych
poleceń SQL do zarządzania bazami danych i użytkownikami, co zapewnia pełną
kontrolę nad procesem.